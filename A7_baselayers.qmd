## Base layers {#sec-appbaselayers}

This appendix provides a practical, hands-on introduction to how the base layers used in [paragraph -@sec-baselayers] were created. You can also use it as a practical, hands-on introduction to some basic and slightly less basic data processing within the GRASS environment for new comers.

For an effective workflow, it is a good idea to organize your data well. For this tutorial, we'll keep the base layers in the [PERMANENT]{.style-data} mapset. We'll use separate mapsets for the input data for our modelling and the modelling results.

### Boundaries {#sec-nationalboundaries}

We'll use the 1:10m scale data from [Natural Earth](https://www.naturalearthdata.com/), a public domain map dataset available at various scales. We download the Shapefile from [Admin 0 - countries](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/) and unzip the data to the working directory. Next, we import the Shapefile in GRASS as [admin0]{.style-data} using [v.in.ogr](https://grass.osgeo.org/grass-stable/manuals/v.in.ogr.html).

::: {#exm-e84zgDAzAIs .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.in.ogr input=ne_10m_admin_0_countries.shp output=admin0
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "v.in.ogr",
    input="ne_10m_admin_0_countries.shp",
    output="admin0",
)
```

## {{< fa regular window-restore >}}

Open the `v.in.ogr` dialog and fill in:

| Parameter | Value                        |
|-----------|------------------------------|
| Input     | ne_10m_admin_0_countries.shp |
| Output    | admin0                       |

: {tbl-colwidths="\[50,50\]"}
:::

The Almond-eyed Ringlet occurs in parts of Europe, so we’ll limit the areas for which we download the rest of the data to Europe, by setting the extent of the computational region (@sec-computationalregion). This can be done using the [g.region](https://grass.osgeo.org/grass-stable/manuals/g.region.html) module. As input we can define the north, south, west and east limits, or we can define these interactively, using the [Set computational region extent interactively]{.style-menu} option under the [Various zoom options]{.style-menu} ![](images/zoom-more.png) button. For the latter, see the [{{< fa regular window-restore >}}]{.paneltabcolor} tab below.

::: {#exm-7Z3CL3lWfe .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
g.region n=55 s=35 w=-10 e=33
```

## {{< fa brands python >}}

``` python
gs.run_command("g.region", n=55, s=35, w=-10, e=33)
```

## {{< fa regular window-restore >}}

{{< video "https://ecodiv.earth/share/sdm_in_grassgis/set_region_extent_interactively.mp4" >}}
:::

The next step is to create a vector layer [aoi]{.style-data} with a polygon representing the boundaries of the region's extent using [v.in.region](https://grass.osgeo.org/grass84/manuals/v.in.region.html).

::: {#exm-skRCyG0NKS .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.in.region output=aoi
```

## {{< fa brands python >}}

``` python
gs.run_command("v.in.region", output="aoi")
```

## {{< fa regular window-restore >}}

Open the `v.in.region` dialog. Fill in:

| Parameter | Value |
|-----------|-------|
| output    | aoi   |

: {tbl-colwidths="\[50,50\]"}
:::

To save some space, we can use the [aoi]{.style-data} vector layer to clip the [admin0]{.style-data} layer to the spatial bounds of the computational region using [v.clip](https://grass.osgeo.org/grass-stable/manuals/v.clip.html), save the result as [countries]{.style-data}, and subsequently remove the [admin0]{.style-data} layer using the [g.remove](https://grass.osgeo.org/grass84/manuals/g.remove.html) module.

::: {#exm-u9sDIGepop .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.clip input=admin0 clip=aoi output=countries
g.remove -f type=vector name=admin0
```

## {{< fa brands python >}}

``` python
gs.run_command("v.clip", input="admin0", clip="aoi", output="countries")
gs.run_command("g.remove", flags="f", type="vector", name="admin0")
```

## {{< fa regular window-restore >}}

Open the `v.clip` dialog, and fill in:

| Parameter | Value     |
|-----------|-----------|
| Input     | admin0    |
| Clip      | aoi       |
| Output    | countries |

: {tbl-colwidths="\[50,50\]"}
:::

### Roads {#sec-roads}

We'll get the road data from Natural Earth as well. Download it from [here](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/roads/) and unzip it into your working directory. Similar to the previous step, we'll import the data as [tmp]{.style-data} using `v.in.ogr` with the [-r]{.style-parameter} flag.

The vector data includes line features representing roads and ferry routes. Whether a line feature is a road or ferry route is defined in the [featurecla]{.style-parameter} column of the attribute table. We only want to import the roads. We can do this using the [where]{.style-parameter} parameter. This parameter takes as SQL [Where](https://www.sqlitetutorial.net/sqlite-where/) query as an argument to select the features that match a particular condition.

::: {#exm-cMoYfaHQwQ .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.in.ogr -r input=ne_10m_roads.shp where="featurecla='Road'" output=tmp
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "v.in.ogr",
    flags="r",
    input="ne_10m_roads.shp",
    where="featurecla='Road'",
    output="tmp",
)
```

## {{< fa regular window-restore >}}

Open the `v.in.ogr` dialog, and fill in:

| Parameter                                  | Value               |
|--------------------------------------------|---------------------|
| Input                                      | ne_10m_roads.shp    |
| Output                                     | tmp                 |
| Where                                      | `featurecla='Road'` |
| Limit the import to the current region (r) | ✅                  |

: {tbl-colwidths="\[50,50\]"}
:::

Next, we clip the layer to the boundaries of our region with [v.clip](https://grass.osgeo.org/grass-stable/manuals/v.clip.html) and remove the temporary data.

In this particular case, we are out of luck, as the resulting vector layer does not have an attribute table. This type of error is often caused by incorrect attribute data, such as hard returns or invalid column names. The latter is the case here. There is a column 'add', which GRASS does not accept. There are two ways to fix this. Rename the offending column with [v.db.renamecolumn](https://grass.osgeo.org/grass-stable/manuals/v.db.renamecolumn.html) or remove it using [v.db.dropcolumn](https://grass.osgeo.org/grass-stable/manuals/v.db.dropcolumn.html). We'll go for the latter solution.

::: {#exm-e84zg44AIs .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
# Remove problematic column
v.db.dropcolumn map=tmp columns=add

# Clip to aoi spatial bounds
v.clip input=tmp clip=aoi output=roads

# Remove temporary data
g.remove -f type=vector name=tmp
```

## {{< fa brands python >}}

``` python
# Remove problematic column
gs.run_command("v.db.dropcolumn", map="tmp", columns="add")

# Clip to aoi spatial bounds
gs.run_command("v.clip", input="tmp", clip="aoi", output="roads")

# Remove temporary data
gs.run_command("g.remove", flags="f", type="vector", name="tmp")
```

## {{< fa regular window-restore >}}

Open the `v.db.dropcolumn` dialog.

| Parameter | Value |
|-----------|-------|
| map       | tmp   |
| column    | add   |

: {tbl-colwidths="\[50,50\]"}

Open the `v.clip` dialog, and fill in:

| Parameter | Value |
|-----------|-------|
| input     | tmp   |
| clip      | aoi   |
| output    | roads |

: {tbl-colwidths="\[50,50\]"}

Open the `g.remove` dialog, and fill in:

| Parameter         | Value  |
|-------------------|--------|
| type              | vector |
| name              | tmp    |
| Force removal (r) | ✅     |

: {tbl-colwidths="\[50,50\]"}
:::

### Rivers {#sec-rivers}

We get the river data from Natural Earth as well ([download link](https://www.naturalearthdata.com/downloads/10m-physical-vectors/10m-rivers-lake-centerlines/)). Download both the [rivers and lake centerlines]{.style-data} and [Europe supplement]{.style-data} Shapefiles and unzip them into your working directory. We'll use the same steps as above to import these layers.

::: {#exm-TpZKQ69XSJ .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.in.ogr -r input=ne_10m_rivers_lake_centerlines.shp output=tmp1
v.in.ogr -r input=ne_10m_rivers_europe.shp output=tmp2
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "v.in.ogr",
    flags="r",
    input="ne_10m_rivers_lake_centerlines.shp",
    output="tmp1",
)
gs.run_command(
    "v.in.ogr",
    flags="r",
    input="ne_10m_rivers_europe.shp",
    output="tmp2",
)
```

## {{< fa regular window-restore >}}

To import [ne_10m_rivers_lake_centerlines.shp]{.style-data}, fill in the following parameters in `v.in.ogr`:

| Parameter | Value |
|----|----|
| input | ne_10m_rivers_lake_centerlines.shp |
| output | tmp1 |
| Limit the import to the current region (r) | ✅ |

: {tbl-colwidths="\[50,50\]"}

And, to import the [ne_10m_rivers_europe.shp]{.style-data}:

| Parameter                                  | Value                    |
|--------------------------------------------|--------------------------|
| input                                      | ne_10m_rivers_europe.shp |
| output                                     | tmp2                     |
| Limit the import to the current region (r) | ✅                       |

: {tbl-colwidths="\[50,50\]"}
:::

We now clip the imported layers to the boundaries of the European mainland.

::: {#exm-OtEsqXpc4Z .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bas
v.clip input=tmp1 clip=aoi output=tmp3
v.clip input=tmp2 clip=aoi output=tmp4
```

## {{< fa brands python >}}

``` python
gs.run_command("v.clip", input="tmp1", clip="aoi", output="tmp3")
gs.run_command("v.clip", input="tmp2", clip="aoi", output="tmp4")
```

## {{< fa regular window-restore >}}

To clip [tmp1]{.style-data}, open the `v.clip` dialog and fill in the following parameters:

| Parameter | Value |
|-----------|-------|
| input     | tmp1  |
| output    | aoi   |
| clip      | tmp3  |

: {tbl-colwidths="\[50,50\]"}

And, to clip [tmp2]{.style-data} to the area of interest (aoi):

| Parameter | Value |
|-----------|-------|
| input     | tmp2  |
| output    | aoi   |
| clip      | tmp4  |

: {tbl-colwidths="\[50,50\]"}
:::

Next step would be to combine the two layers [tmp3]{.style-data} and [tmp4]{.style-data}. However, the columns in the attribute tables of the two layers are different, both in their names and their order. To make these tables compatible, we need to rearrange and rename the columns so that both tables have the same structure. This requires some SQL code, which we can run using the [db.execute](https://grass.osgeo.org/grass-stable/manuals/db.execute.html) module. We first rename the original tables.

::: {#exm-HnzBvCZB2Y .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
# Rename the attribute tables
db.execute sql="ALTER TABLE tmp3 RENAME TO tmp3old;"
db.execute sql="ALTER TABLE tmp4 RENAME TO tmp4old;"
```

## {{< fa brands python >}}

``` python
# Rename the attribute tables
gs.run_command(
    "db.execute",
    sql="ALTER TABLE tmp3 RENAME TO tmp3old;",
)
gs.run_command(
    "db.execute",
    sql="ALTER TABLE tmp4 RENAME TO tmp4old;",
)
```

## {{< fa regular window-restore >}}

To rename the table [tmp3]{.style-data} to [tmp3old]{.style-data}, open the `db.execute` dialog and, and in the [sql]{.style-parameter} field, we use the SQL [ALTER TABLE](https://www.tutorialspoint.com/sqlite/sqlite_alter_command.htm) command to rename the attribute tables of [tmp3]{.style-data}.

| Parameter | Value                                |
|-----------|--------------------------------------|
| sql       | `ALTER TABLE tmp3 RENAME TO tmp3old` |

: {tbl-colwidths="\[50,50\]"}

Likewise, to rename the table [tmp4]{.style-data}:

| Parameter | Value                                |
|-----------|--------------------------------------|
| sql       | `ALTER TABLE tmp4 RENAME TO tmp4old` |

: {tbl-colwidths="\[50,50\]"}

## {{< fa question >}}

We use the SQLite [ALTER TABLE](https://www.tutorialspoint.com/sqlite/sqlite_alter_command.htm) command to renames the existing attribute table. This will decouple them from the vector layer (geometry).

:::

We then create new tables with a subset of columns from the original tables. We give these new tables the name of the original attribute tables. GRASS will automatically use these now as attribute tables.

::: {#exm-Zr2t5IdNW1 .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
# Create new tables  
db.execute sql="CREATE TABLE tmp3 AS SELECT cat,scalerank,featurecla,name,label,min_zoom,min_label FROM tmp3old"
db.execute sql= "CREATE TABLE tmp4 AS SELECT cat,scalerank,featurecla,name,label,min_zoom,min_label FROM tmp4old"
```

## {{< fa brands python >}}

``` python
# New attribute tables
gs.run_command( 
    "db.execute",
    sql=(
        "CREATE TABLE tmp3 AS "
        "SELECT cat,scalerank,featurecla,name,label,min_zoom,min_label "
        "FROM tmp3old"
    ),
)
gs.run_command(
    "db.execute",
    sql=(
        "CREATE TABLE tmp4 AS "
        "SELECT cat,scalerank,featurecla,name,label,min_zoom,min_label "
        "FROM tmp4old"
    ),
)
```

## {{< fa regular window-restore >}}

To create a new attribute tables [tmp3]{.style-data} with a subset of the columns from [tmp3old]{.style-data}, open the `db.execute` dialog, and run it with the following SQL code:

| Parameter | Value |
|----|----|
| sql | `CREATE TABLE tmp3 AS SELECT cat,scalerank,featurecla,name,label,min_zoom,min_label FROM tmp3old` |

: {tbl-colwidths="\[10,90\]"}

And to create a new attribute tables [tmp4]{.style-data} with a subset of the columns from [tmp4old]{.style-data}:

| Parameter | Value |
|----|----|
| sql | `CREATE TABLE tmp4 AS SELECT cat,scalerank,featurecla,name,label,min_zoom,min_label FROM tmp4old` |

: {tbl-colwidths="\[10,90\]"}

## {{< fa question >}}

We use the SQLite [CREATE TABLE](https://www.tutorialspoint.com/sqlite/sqlite_create_table.htm) command to create a new table with the original name, but with the correct structure, based on a selection of columns from the table we just renamed in the order we want. Note, this includes the [cat]{.style-data} column, which is used to link the table attributes to the vector features (see @sec-attributemanagement). The new table gets the name of the original table.

:::

After we have assured the attribute tables of both layers have the same structure, we use [v.patch](https://grass.osgeo.org/grass-stable/manuals/v.patch.html) to combine them into one layer called [rivers]{.style-data}.

::: {#exm-Qh4ZzKINHT .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.patch input=tmp3,tmp4 output=rivers
```

## {{< fa brands python >}}

``` python
gs.run_command("v.patch", input=["tmp3", "tmp4"], output="rivers")
```

## {{< fa regular window-restore >}}

To patch the two vector layers [tmp3]{.style-data} and [tmp4]{.style-data}, open the `v.patch` dialog and run the function with the following parameters:

| Parameter | Value     |
|-----------|-----------|
| input     | tmp3,tmp4 |
| output    | rivers    |

: {tbl-colwidths="\[30,70\]"}
:::

Last step is to remove the temporary layers. We use [db.droptable](https://grass.osgeo.org/grass-stable/manuals/db.droptable.html) to remove the 'stand-alone' tables, and [g.remove](https://grass.osgeo.org/grass-stable/manuals/g.remove.html) to remove the intermediate vector layers. We use the [pattern]{.style-parameter} parameter and a wildcard to remove all vector layers with a name that start with [tmp]{.style-parameter}. See the `g.remove` [manual page](https://grass.osgeo.org/grass-stable/manuals/g.remove.html) for more details.

::: {#exm-FlhdR7On5I .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
db.droptable -f table=tmp3old
db.droptable -f table=tmp4old
g.remove -f type=vector pattern=tmp*
```

## {{< fa brands python >}}

``` python
gs.run_command("db.droptable", flags="f", table="tmp3old")
gs.run_command("db.droptable", flags="f", table="tmp4old")
gs.run_command("g.remove", flags="f", type="vector", pattern="tmp*")
```

1.  The `db.droptable` module runs the SQLite [DROP TABLE](https://www.tutorialspoint.com/sqlite/sqlite_drop_table.htm) function in the background to remove the old table.

## {{< fa regular window-restore >}}

Open the `db.droptable` dialog, and use the following parameter settings:

| Parameter | Value   |
|-----------|---------|
| table     | tmp3old |

: {tbl-colwidths="\[30,70\]"}

Repeat this, but replace [tmp3old]{.style-parameter} with [tmp4old]{.style-parameter}.

Run `g.remove` with the following parameter settings:

| Parameter         | Value  |
|-------------------|--------|
| type              | vector |
| pattern           | tmp\*  |
| Force removal (r) | ✅     |

: {tbl-colwidths="\[30,70\]"}

## {{< fa question >}}

The `db.droptable` module runs the SQLite [DROP TABLE](https://www.tutorialspoint.com/sqlite/sqlite_drop_table.htm) function in the background to remove the old table.

:::

### Land cover {#sec-landcover}

Land use plays a crucial role in determining the distribution of many species. The [CORINE Land Cover](https://land.copernicus.eu/en/products/corine-land-cover) (CLC) dataset provides a comprehensive pan-European inventory of land cover and land use. It categorizes the landscape into 44 thematic classes, ranging from broad forested areas to detailed land uses such as vineyards. Updated every six years, the dataset offers both status and change layers, making it a valuable resource for ecological studies.

For this tutorial, we will use the most recent raster layer (as of this writing, the 2018 update) to represent land use. You can [download the dataset here](https://land.copernicus.eu/en/products/corine-land-cover/clc2018#download) (you'll need to have/make an account). After downloading, unzip the files to your working directory.

Once the dataset is ready, import the raster layer into GRASS using the [r.import](https://grass.osgeo.org/grass-stable/manuals/r.import.html) module. This tool allows you to import raster data into GRASS while automatically reprojecting the data if its coordinate system differs from that of your current project. We let the module estimate the target resolution by setting the [resolution]{.style-parameter} to [estimates]{.style-parameter}. As resampling method, we use [nearest]{.style-parameter} (this is the default).

::: {#exm-5LWdebt7OV .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
r.import extent=region resolution=estimated resample=nearest input=U2018_CLC2018_V2020_20u1.tif output=CLC2018 title=U2018_CLC2018_V2020_20u1 memory=1000 
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "r.import",
    extent="region",
    resolution="estimated",
    resample="nearest",
    input="U2018_CLC2018_V2020_20u1.tif",
    output="CLC2018",
    title="U2018_CLC2018_V2020_20u1",
    memory=1000,
)
```

## {{< fa regular window-restore >}}

Run the module `r.import` with the following parameters.

| Parameter  | Value                        |
|------------|------------------------------|
| extent     | region                       |
| resolution | estimated                    |
| resample   | nearest                      |
| input      | U2018_CLC2018_V2020_20u1.tif |
| output     | CLC2018                      |
| title      | U2018_CLC2018_V2020_20u1     |
| memory     | 1000                         |

: {tbl-colwidths="\[50,50\]"}
:::

To assign category labels to our land use map, we use the [r.category](https://grass.osgeo.org/grass-stable/manuals/r.category.html) module. This module allows users to assign category labels to raster values using rules from a text file. The file should have no header, with each line formatted as `raster_value|raster_label` (using a pipe as the separator).

The raster values and labels can be extracted from the [U2018_CLC2018_V2020_20u1.tif.vat.dbf]{.style-file} file, which is included in the downloaded land use map. Open this file in LibreOffice or Excel. The first column contains the raster values, and the third column contains the labels. Use this data to create a category rules file by copying the values and labels into a text file (without the header)[^2_obtaining_data-5]. Save the file as [corina_clc_categories.txt]{.style-file} in your working directory, and apply it using:

[^2_obtaining_data-5]: If you don't know how to do this, see [this spreadsheet](share/corina_reclass_color_rules.ods). You can copy the values from the *category rules* column (without the header) to a text file and save it in your working directory as [corina_clc_categories.txt]{.style-file}.

::: {#exm-BcEwmgX1sG .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
r.category map=CLC2018 separator=pipe rules=corina_clc_categories.txt
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "r.category", map="CLC2018", separator="pipe", rules="corina_clc_categories.txt"
)
```

## {{< fa regular window-restore >}}

Run `r.category` with the following parameters:

| Parameter | Value                     |
|-----------|---------------------------|
| map       | CLC2018                   |
| separator | pipe                      |
| rules     | corina_clc_categories.txt |

: {tbl-colwidths="\[50,50\]"}
:::

To assign a color table to the map, we use the [r.colors](https://grass.osgeo.org/grass-stable/manuals/r.colors.html) module. Color rules can be created using values from columns 1, 4, 5, and 6 of the same [.dbf]{.style-file} file. The `r.colors` manual page provides information about the required format. Or you can follow the example in the [accompanying spreadsheet](share/corina_reclass_color_rules.ods) to create the color rules file. Save it as [corina_clc_colorrules.txt]{.style-file} and apply it using:

::: {#exm-BcEwmgX1sG .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
r.colors map=CLC2018 rules=corina_clc_colorrules.txt
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "r.colors", map="CLC2018", rules="corina_clc_colorrules.txt"
)
```

## {{< fa regular window-restore >}}

| Parameter | Value                     |
|-----------|---------------------------|
| map       | CLC2018                   |
| rules     | corina_clc_colorrules.txt |

: {tbl-colwidths="\[50,50\]"}
:::

Keep in mind that we imported the land cover raster at approximately its original resolution. For further analyses with this layer, it may be necessary to resample this layer so it matches the resolution of other raster layers. GRASS can handle resampling automatically "on the fly", which is convenient. However, it’s important to think critically about whether the default nearest neighbor method is truly the best option. We’ll revisit this topic later, but for now, make a note of it.

