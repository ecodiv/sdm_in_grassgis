---
lightbox:
  match: auto
  effect: none
  loop: true
---

# Acquire the data {#sec-data}

For this tutorial, we will download and import various data layers that we need to develop a potential distribution model/map for our species, the almond-eyed ringlet (*Erebia alberganus*). This includes species distribution data and environmental data layers. For visualization purposes, we'll use some background layers, including a map of the national borders of European countries, rivers, major roads and urban areas in Europe. 

## The database {#sec-creatingadatabase}

Once you have started GRASS, the first thing you normally do is to open the GRASS database, or to create a new one to do for this tutorial is to create a new GRASS database called [GRASSdb]{.style-data}. Next, create a new project called [SDM]{.style-data} with the coordinate reference system (CRS) [WGS84 lat/lon]{.style-parameter} ([EPSG 4326](https://epsg.io/4326)). The easiest way to do this is using the GUI, but if you want to make it part of an automated process, you can do this in Python as well.

::: {#exm-2vSeGTk3HW .hiddendiv}
:::

::: panel-tabset
## {{< fa regular window-restore >}}

{{< video "https://ecodiv.earth/share/sdm_in_grassgis/create_project.mp4" >}}

## {{< fa brands python >}}

``` python
# Create the folder for the GRASS database
os.mkdir("path_to_directory")

# Create a new Project
gs.create_project(
    path="path_to_directory/GRASSdb",
    name="SDM",
    epsg="4326",
)

# Change to the newly created Project / mapset
gs.run_command("g.mapset", mapset="PERMANENT", project="SDM")
```

## {{< fa question >}}

Replace the `path_to_directory` with the path to the directory where you want to create the database. Note, on Windows, paths are written using backslashes (\\) as the separator between folder names. On Unix based operating system such as macOS, Linux, and BSDs, the forward slash (/) is used as the path separator.
:::

Now that you have your database ready, you can start with the next step, which is getting and preparing the input data for the species distribution modeling.

## Working directory {#sec-workingdirectory}

Some GRASS GIS modules require a file as input or produce a file as output. You can always specify the full file path. However, if you define a working directory and store your files there, you only need to provide paths relative to that directory.

It is therefore recommended to create your own dedicated working directory and use it to store the downloaded data. The working directory is the folder where GRASS looks for input files and where it writes output files, helping to keep your project organized and your data management efficient.

::: {.callout-warning appearance="simple"}
Never use the GRASS database directory, that you created in the previous section, for this. The GRASS directory is for GRASS data only
:::

::: {#exm-qpbGaVxfYh .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

Type `cd` followed by the path to the working directory in the [wxGUI Command Console]{.style-menu}. If you prefer to work on the terminal, run the same on the terminal.

``` bash
cd replace-for-path-to-working-directory
```

## {{< fa brands python >}}

``` python
import os
os.chdir("replace-for-path-to-working-directory")
```

## {{< fa regular window-restore >}}

The working directory can also be changed in wxGUI menu [Settings → GRASS working environment → Change working directory]{.style-menu}

![Set the working directory via the menu or using the command line. After doing so, GRASS will look for files in that location if the full path is not provided.](images/setworkingdirectory.png){#fig-setworkingdirectory}

## {{< fa question >}}

Replace `path_to_working_directory` with the path to the folder that you want to use as the working directory.

Be aware that file path notation differs between operating systems. On Windows, backslashes (`\`) are used to separate folder names. On Unix-based operating systems, such as macOS, Linux, and BSD, forward slashes (`/`) are used instead.
:::

Now, whenever you have to refer to an external file, such as text files or GeoTiff files, it is enough to specify the name of the file instead of the full path. 

## Base layers {#sec-baselayers}

We'll import a few base layers, including maps of the national boundaries, roads, rivers, and land use. They will serve as reference layers[^2_obtaining_data-2]. 

![This is the study area, which includes the national boundaries, main roads, and shaded relief (source: [Natural Earth](https://www.naturalearthdata.com/)) and the urban areas (source: [GLC](https://land.copernicus.eu/en/products/corine-land-cover)). See [@sec-appbaselayers] for information on how these layers were created.](images/reference_layers.png){#fig-baselayers}

[^2_obtaining_data-2]: *Reference layers* are datasets that provide context and help you to visually navigate the map and understand the geographic setting of the area being analyzed. One of the key advantages of modeling in a GIS environment is the ability to seamlessly integrate and compare model outcomes with these reference layers, and thus to explore and interpret results in their geographic context.

First, download the Geopackage [sdm_base_layers.gpkg](https://ecodiv.earth/share/sdm_in_grassgis/sdm_base_layers.gpkg) and copy the file to your working directory. A GeoPackage (GPKG) is an open, standards-based geospatial data format that can contain one data layer or multiple layers. This GPKG contains three vector layers with respectively the boundries of European countries ([countries]{.style-data}), the main rivers ([rivers]{.style-data}) and the roads ([roads]{.style-data}) in Europe. Import these layers in GRASS.

::: {#exm-XmMn498Mh .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
v.in.ogr input=sdm_base_layers.gpkg layer=countries output=countries
v.in.ogr input=sdm_base_layers.gpkg layer=roads output=roads
v.in.ogr input=sdm_base_layers.gpkg layer=rivers output=rivers
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "v.in.ogr", input="sdm_base_layers.gpkg", layer="countries", output="countries"
)
gs.run_command(
    "v.in.ogr", input="sdm_base_layers.gpkg", layer="roads", output="roads"
)
gs.run_command(
    "v.in.ogr", input="sdm_base_layers.gpkg", layer="rivers", output="rivers"
)

```

## {{< fa regular window-restore >}}

Open  [File → v.in.ogr]{.style-menu} menu or [Toolbox → v.in.ogr]{.style-menu} and on the first tab [Required]{.style-menu} find the GeoPackage you just downloaded. Or, if you copied the file to your working directory, you can simply fill in the name of the file under the [Source input]{.style-menu}.

![Name of the GeoPackage](images/baselayers_countries_step1.png){#fig-bcs1 fig-align="left" width=500}

Next, under the [Input]{.style-menu} tab, select the layer [countries]{.style-parameter}. Leave the others unselected.

![Layer to import](images/baselayers_countries_step2.png){#fig-bcs1 fig-align="left" width=500}

And as last step, under the [Output]{.style-menu} tab, give the output layer the name [countries]{.style-parameter}

![Layer to import](images/baselayers_countries_step3.png){#fig-bcs1 fig-align="left" width=500}

Now, repeat these steps for the other two layers, naming them [roads]{.style-parameter} and the [rivers]{.style-parameter}, respectively.


## {{< fa question >}}

Note, the assumption is that the GeoPackage file is in your working directory, which you defined in @exm-qpbGaVxfYh. If not, you will have to provide the full path to the file.

When using `v.in.ogr`, a GeoPackage is treated as a container of separate layers, not a single dataset. That means that if the GeoPackage contains multiple layers, each layer must be explicitly specified and imported individually.

:::

Next, download the Copernicus 90m DEM [(cop90.tif)](https://ecodiv.earth/share/sdm_in_grassgis/cop90.tif), the shaded relief map ([shaded_relief.tif](https://ecodiv.earth/share/sdm_in_grassgis/shaded_relief_NE.tif)) and the Urban areas map ([urban_areas.tif](https://ecodiv.earth/share/sdm_in_grassgis/urban_areas.tif)) and copy the files to your working directory. Next, import these layers in GRASS with the `r.in.gdal` function.


::: {#exm-Xm99Mh .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
# Import urban areas raster
r.in.gdal input=urban_areas.tif output=urban_areas

# Import shaded relief raster
r.in.gdal input=shaded_relief.tif output=shaded_relief

# Import the digital elevation model (cop90)
r.in.gdal input=cop90.tif output=cop90

```

## {{< fa brands python >}}

``` python
# Import urban areas raster
gs.run_command(
    "r.in.gdal",
    input="urban_areas.tif",
    output="urban_areas"
)

# Import shaded relief raster
gs.run_command(
    "r.in.gdal",
    input="shaded_relief_NE.tif",
    output="shaded_relief_NE"
)

# Import the digital elevation model (eudem)
gs.run_command(
    "r.in.gdal",
    input="eudem.tif",
    output="eudem"
)
```

## {{< fa regular window-restore >}}

Open the `r.in.gdal` from the [File]{.style-menu} menu or from the [Toolbox]{.style-menu} and on the first tab [Required]{.style-menu} 

- Select as input the GeoTiff file [urban_areas.tif]{.style-data}
- Set the name of the output raster layer as [urban_areas]{.style-parameter}.
- Click on [Run]{.style-menu}

Repeat for the shaded relief map:

- Select as input the GeoTiff file [shaded_relief_NE.tif]{.style-data}
- Set the name of the output raster layer as [shaded_relief_NE]{.style-parameter}.
- Click on [Run]{.style-menu}

Repeat for the digital elevation model (eudem) map:

- Select as input the GeoTiff file [eudem.tif]{.style-data}
- Set the name of the output raster layer as [eudem]{.style-parameter}.
- Click on [Run]{.style-menu}

:::

Open the layers in the Layers panel and style them as you like. You can also add any other layer. For example, you can add the Corina land use layer. I'll leave that as an exercise for you.

## Species range map {#sec-rangemap}

To get an idea of the distribution of our species, we first consult expert-derived range information. A commonly used source is the [IUCN Red List](https://www.iucnredlist.org/).

Visit the website and log in. If you do not yet have an account, create one first. Use the search bar to find the species, preferably by its scientific name.

::: {.callout-note}
The IUCN Red List uses a different scientific name for this species, namely _Erebia albergana_. This is something to be aware of; scientific names are not always used consistently across data sources.
:::

Download the range data and unzip the files into your working directory. If you plan to use these data in a report or publication, note the citation information provided on the webpage (below the Abstract). Recording this information now will save time later and helps ensure proper data attribution.

Next, create a new mapset called [Erebia_alberganus]{.style-data}. This mapset will be used to store the distribution data of our species. Import the downloaded range map into this mapset. Because the mapset itself already identifies the species, the names of the layer is kept generic, for example rangemap and occurrences.

This naming strategy only works if a mapset is dedicated to a single species. If you store data for multiple species in the same mapset, layer names would need to include the species name or another clear identifier to avoid confusion.

::: {#exm-XmMn4IG2Mh .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
g.mapset -c mapset=Erebia_alberganus
v.in.ogr input=data_0.shp output=rangemap
```

## {{< fa brands python >}}

``` python
gs.run_command("g.mapset", flags="c", mapset="Erebia_alberganus")
gs.run_command(
    "v.in.ogr",
    input="data_0.shp",
    output="rangemap",
)
```

## {{< fa regular window-restore >}}

Type in `g.mapset` in the console to open the dialog, and use the following parameter settings.

| Parameter                             | Value             |
|---------------------------------------|-------------------|
| mapset                                | Erebia_alberganus |
| Create mapset if it doesn't exist (c) | ✅                |

: {tbl-colwidths="\[50,50\]"}

Run `v.in.ogr with the following parameter settings:

| Parameter | Value                      |
|-----------|----------------------------|
| input     | data_0.shp                 |
| output    | rangemap                   |

: {tbl-colwidths="\[50,50\]"}
:::

## Species occurrences {#sec-occurrence}

The Global Biodiversity Information Facility ([GBIF](https://www.gbif.org/)) provides openly accessible records of species occurrences, which is the primary type of data used in species distribution modeling. 

::: {.aside}
::: {.callout-note appearance="default" title="About GBIF"}
GBIF is an international biodiversity informatics infrastructure that aggregates occurrence data spanning more than three centuries of natural history, including historical museum specimens and contemporary observations. These data are contributed by a wide range of sources, such as research institutions, citizen science initiatives, and automated monitoring programs, and are made freely available under open-data principles.
:::
:::

Before downloading data, you must first register on the site. Once logged in, search for *Erebia alberganus* von Prunner, 1798. Select the result and open the page. Then click on the green button with the number of observations to open the table with observations.

![At the time of writing, GBIF had 20410 occurrences of *Erebia alberganus*. After applying the filters described below, 17,348 records remained](images/numberofoccurrences.png){#fig-numerofoccurrences fig-align="left"}

In the new window, apply the filters you consider relevant. For example, under [Basis of record]{.style-menu}, select [Human observation]{.style-menu} and [Occurrences]{.style-menu} to exclude fossil records or machine-based observations. You may also restrict the data to a specific time period, for example, the last 45 years.

Finally, check the [Issues and flags]]{.style-menu} section to exclude records with known problems, such as missing coordinates. If you only want to exclude a few issues, you can reverse the selection at the bottom of the list.

Note which filters and what settings you used to select the records. Tip: open the map tab and check the map each time you change a filter to see how it affects the selection of observations.

![The table shows all occurrence records for our species. In the panel at the left, you can select specific records based on a number of criteria.](images/gbifoccurrencefilters.png){#fig-gbiffilters fig-align="left"}

Click on the [download]{.style-menu} tab and select the [Simple]{.style-menu} option. This will take you to the download page (it may take a while to complete, but you get an email when the download is ready). When the download is complete, download the file and unzip into to your data .

::: callout-tip
It is good practice to cite the data you use in your publications. GBIF conveniently provides you with the citation on the download page, including a Digital Object Identifier (DOI). This is a link to a web page that describes your search, including any filters you have set. Copy and save the citation, so you can use it in your report. If you are using a reference manager such as [Zotero](https://www.zotero.org/) (highly recommended), you can use the provided BibTex or RIS file to import the reference.
:::

The downloaded file is a tab delimited text file, which can be imported with the [v.in.ascii](https://grass.osgeo.org/grass-stable/manuals/v.in.ascii.html) module. A more convenient way is to import the downloaded data using the [v.in.gbif](https://grass.osgeo.org/grass-stable/manuals/addons/v.in.gbif.html) module. It's an addon, so install it if you haven't done so yet.

::: {#exm-EZ65hmOvkK .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

Replace the name of the input file with the name of the CSV file you downloaded from GBIF.

``` bash
v.in.gbif input=0069182-251120083545085.csv output=occurrences
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "v.in.gbif", input="DataFiles/speciesdata/0069182-251120083545085.csv", output="occurrences"
)
```

## {{< fa regular window-restore >}}

Open the `v.in.gbif` dialog, and run it with the following parameter settings:

| Parameter | Value                       |
|-----------|-----------------------------|
| input     | 0069182-251120083545085.csv |
| output    | occurrences       |

: {tbl-colwidths="\[50,50\]"}
:::

After importing the data in GRASS, it is good practice to check carefully for outliers and other possible problems. If you zoom to the extent of the data, you may find out that there are a outliers that are clearly erroneous, such as points in the ocean. A common problem is features with coordinates at (0, 0). These typically indicate records with missing coordinates that were filled with zeros during data preparation or import. You can easily identify such cases by opening the attribute table and sorting by [g.decidmallatitude]{.style-parameter} or [decimalLongitude]{.style-parameter} (click on the column header). 

::: {#exm-84575 .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

You can remove these points using the [v.db.droprow](https://grass.osgeo.org/grass-stable/manuals/v.db.droprow.html) module, which creates a new vector map containing only the features that do not match the selection criteria. 

``` bash
# Select and remove features
v.db.droprow input=occurrences where="g_decimallatitude=0" output=temp
```

Because `v.db.droprow` does not allow to modify data in place, the subsequent [g.rename](https://grass.osgeo.org/grass-stable/manuals/g.rename.html) step is used to replace the original vector map with the cleaned version and remove the temporary intermediate map.

``` bash
# Replace previous layer with current version, using the original name
g.rename vector=temp,occurrences --overwrite
```

## {{< fa brands python >}}

You can remove these points using the [v.db.droprow](https://grass.osgeo.org/grass-stable/manuals/v.db.droprow.html) module, which creates a new vector map containing only the features that do not match the selection criteria. 

``` python
gs.run_command(
    "v.db.droprow",
    input="occurrences@Erebia_alberganus",
    where="g_decimallatitude=0",
    output="temp"
)
```

Because `v.db.droprow` does not allow to modify data in place, the subsequent [g.rename](https://grass.osgeo.org/grass-stable/manuals/g.rename.html) step is used to replace the original vector map with the cleaned version and remove the temporary intermediate map.

``` python
# Replace previous layer with current version, using the original name
gs.run_command("g.rename", vector="temp,occurrences", overwrite=True)
```


## {{< fa regular window-restore >}}

Open the `v.db.droprow` dialog, and run it with the following parameter settings:

| Parameter | Value                           |
|-----------|---------------------------------|
| input       | occurrences@Erebia_alberganus |
| where       | g_decimallatitude=0           |
| output      | temp                          |

Because `v.db.droprow` does not allow to modify data in place, the subsequent [g.rename](https://grass.osgeo.org/grass-stable/manuals/g.rename.html) step is used to replace the original vector map with the cleaned version and remove the temporary intermediate map. Run it with the following parameter settings:

| Parameter | Value                |
|-----------|----------------------|
| vector       | temp,occurrences  |
| overwrite    | ✅                |


: {tbl-colwidths="\[50,50\]"}


## {{< fa question >}}

Here are several alternative ways to remove these erroneous points:

- One option is to use v.edit to delete the points directly. Be aware, however, that this approach removes only the geometries; the corresponding rows in the attribute table remain.
- Alternatively, you can open the occurrences attribute table, sort by g_decimallatitude, select the rows where g_decimallatitude = 0, then right-click and choose Delete selected features.
- You can also remove the points manually in editing mode. Activate editing by clicking the pencil icon in the Layers panel, select the points with latitude 0, and delete them.
- Another option is to use [v.extract](https://grass.osgeo.org/grass-stable/manuals/v.extract.html) to create a new layer containing only valid points—for example, by extracting all features with latitude greater than 0.

Being aware of these alternatives is useful, as the most appropriate method depends on the specific task and your familiarity with the available tools.

:::

Not all errors are that obvious. To identify other potential problems, you will need to visually inspect the data and compare them with other sources of information, like the RED list range map (@fig-rangemapoccurrences). 

One likely error in the data are the points on the northern coast of France (@fig-rangemapoccurrences). These points are far outside the known range of the species, so we are going to assume that these are errors. You can check that these points are above 50 degrees latitude. We can delete them in the same way as the previous example.

::: {#exm-845752 .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
# Select and remove features
v.db.droprow input=occurrences where="g_decimallatitude>=50" output=temp

# Replace previous layer with current version, using the original name
g.rename vector=temp,occurrences --overwrite
```

## {{< fa brands python >}}

``` python
# Remove the features (points)
gs.run_command(
    "v.db.droprow",
    input="occurrences",
    where="g_decimallatitude>=50",
    output="temp"
)

# Replace previous layer with current version, using the original name
gs.run_command(
    "g.rename",
    vector="temp,occurrences",
    overwrite=True,
)
```

## {{< fa regular window-restore >}}

Open the `v.db.droprow` dialog, and run it with the following parameter settings:

| Parameter | Value                           |
|-----------|---------------------------------|
| input       | occurrences@Erebia_alberganus |
| where       | g_decimallatitude>=50           |
| output      | temp                          |

Run `g.rename` with the following parameter settings:

| Parameter | Value                |
|-----------|----------------------|
| vector       | temp,occurrences  |
| overwrite    | ✅                |


: {tbl-colwidths="\[50,50\]"}

## {{< fa question >}}

You could also combined @exm-84575 and this step into a single command to select and drop the points.

``` bash
# Select and remove features
v.db.droprow input=occurrences where="g_decimallatitude>=50 OR g_decimallatitude=0" output=temp

# Replace previous layer with current version, using the original name
g.rename vector=temp,occurrences --overwrite
```

You can obviously do the same in Python as well.

:::

There are a few other discrepancies between the range map and the occurrence data (@fig-rangemapoccurrences), which you normally would want to further check. However, for the sake of this tutorial, we'll assume that the GBIF data is OK.

![The Red List range map (green outline) and the GBIF occurrence data of *Erebia alberganus*. Blue outlines indicate some possible problems. See [here](#sec-rangemapoccurrences) for the code used to create this map.](images/rangemap.png){#fig-rangemapoccurrences fig-align="left"}

We have now the species occurrence data ready for modeling. Next step is to download the various environmental layers that will be used as explanatory variables in the modeling.

## Current climate {#sec-climatedata}

As explanatory variables for the species distribution modeling, we'll use the 19 bioclimatic variables from Worldclim[@fick2017]. Bioclimatic (or bioclim in short) variables are derived from the monthly temperature and rainfall values in order to generate more biologically meaningful variables. 

::: {.aside}
::: {.callout-note appearance="default" title="Bioclim variables"}
The bioclimatic variables represent annual trends (e.g., mean annual temperature, annual precipitation) seasonality (e.g., annual range in temperature and precipitation) and extreme or limiting environmental factors (e.g., temperature of the coldest and warmest month, and precipitation of the wet and dry quarters). See [this page](https://worldclim.org/data/bioclim.html) for a description of all 19 variables.
<br>

:::
:::

You can download historical and future climate data. The former represents climate conditions for the period 1970-2000. For the modeling exercise, they are considered to represent the recent / current climate conditions. 

Both historical and future data sets are available in raster format at different resolutions. Go to the [Download page](https://www.worldclim.org/data/worldclim21.html#), download the 2.5 arc minutes historical bioclim data (@fig-worldclimhistoricbioclim) and unzip the GeoTiff files to your working directory. 

![The Worldclim download page for the version 2.1 historical climate data, with the download link for the 2.5 arc-minutes bioclim variables. You can download the data at another resolution as well. If you do, make sure to to adapt the relevant code examples accordingly.](images/worldclim_historic_bioclim.png){#fig-worldclimhistoricbioclim fig-align="left"}

We'll create a new mapset [climate]{.style-data} to store the climate data, using the [g.mapset](https://grass.osgeo.org/grass-stable/manuals/g.mapset.html) module with the [-c]{.style-parameter} flag. Next, we use the [g.region](https://grass.osgeo.org/grass-stable/manuals/g.region.html) module to set the boundaries of the region for which we want to import the data. 

::: {.callout-note appearance="simple"}

Be aware that a new mapset starts with default settings for the computational region. This means that the region set earlier for the [Parameter]{.style-data} mapset does not apply to the new [climate]{.style-data} mapset. Each mapset has its own computational region settings
:::

One option is to use the region extent we defined earlier. Or, now that we know more precisely where our species has been observed, we can defined new bounds using the `g.region` module with the [n]{.style-parameter}, [s]{.style-parameter}, [e]{.style-parameter}, and [w]{.style-parameter} parameters (see below). We set the resolution to match that of the climate layers. This is 2.5 arc minutes, which is equal to 2.5 / 60 = 0.041666666666667. 

::: {#exm-OgizA6dRXy .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
g.mapset -c mapset=climate
g.region n=54 s=36 w=-10 e=32 res=0.041666666666667
```

## {{< fa brands python >}}

First, we create a new mapset.

``` python
gs.run_command("g.mapset", flags="c", mapset="climate")
gs.run_command("g.region", n=54, s=36, w=-10, e=32, res=0.041666666666667)
```

## {{< fa regular window-restore >}}

Type in `g.mapset` in the console to open the dialog, and use the following parameter settings.

| Parameter                             | Value           |
|---------------------------------------|-----------------|
| Name of mapset (mapset)               | climate |
| Create mapset if it doesn't exist (c) | ✅              |

: {tbl-colwidths="\[50,50\]"}

Next, we define the computational region for the new mapset. Open the `g.region` dialog, and use the following parameter settings.

| Parameter                       | Value   |
|---------------------------------|---------|
| Value for the northern edge (n) | 54      |
| Value for the southern edge (s) | 36      |
| Value for the eastern edge (e)  | 32      |
| Value for the western edge (w)  | -10     |
| 2D grid resolution (res)        | 0.041666666666667 |

: {tbl-colwidths="\[50,50\]"}

Alternatively, you can define the region's bounds manually in the [Map display]{.style-menu}, as explained in @sec-computationalregion.

## {{< fa question >}}

Note that, if the region and the raster layer are not perfectly aligned, the area that is imported will be slightly larger than the computational region. How much larger depends on the resolution of the computational region, as explained in (@sec-computationalregion). We therefore use the [res]{.style-parameter} parameter to set the resolution to match the resolution of the layers we want to import.

Remember to calculate the resolution in decimal degrees. For 2.5 arc minutes, this is 2.5 / 60 = 0.041666666666667. If you work at another resolution, make sure to adapt this value accordingly. For example, when working with 30 arc seconds data, the resolution would be 30 / 3600 = 0.00833333333333333 degrees.

:::

To import the bioclim data, we use [r.in.gdal](https://grass.osgeo.org/grass-stable/manuals/r.in.gdal.html) with the [-r]{.style-parameter} flag to tell GRASS to limit the import of the data to the area defined by the computational region that we defined in the previous step. To speed up the import, we use the [memory]{.style-parameter} parameter to set the maximum memory to be used (in MB) to be equal to the size of the input file (or otherwise to the maximum amount available on your system).

To avoid having to type in the same command 19 times, we can use a small script to automate the process. If you prefer to use the GUI, the [r.import](https://grass.osgeo.org/grass-stable/manuals/r.import.html) functions offers the possibility to batch import layers, as illustrated in the video under the [{{< fa regular window-restore >}}]{.paneltabcolor} tab.

::: {#exm-vavvH110fv .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
base="wc2.1_2.5m_bio_"
for n in {1..19}; do
    input="${base}${n}.tif"
    output="bio_${n}"
    r.in.gdal -r input=${input} output=${output} memory=1000
done
```

## {{< fa brands python >}}

``` python
base = "wc2.1_2.5m_bio_"
for n in range(1, 20):
    input = f"{base}{n}.tif"
    output = f"bio_{n}"
    gs.run_command(
        "r.in.gdal",
        flags="r",
        input=input,
        output=output,
        memory=1000,
    )
```

## {{< fa regular window-restore >}}

{{< video "https://ecodiv.earth/share/sdm_in_grassgis/import_climate_data.mp4" >}}


## {{< fa question >}}

The code does the follow.

In the first line, you define the base name `wc2.1_30s_bio_`. Note that if you downloaded the lower resolution data, you need to change this to match the base name of the GeoTIFF files that you downloaded. In the for loop, the base name, number and file extension will be combined to the name of the file to be imported.

The 'for' loop will import the layer 1 to 19. Each round, 

1. the names of the input and output layers are created and used as input for r.in.gdal.
2. The number and file extension are added to complete the path+name of the file to be imported.
3.  The name of the imported raster layer is created by combining the base name (bio\_) and the number.

In the `r.in.gdal` command:

- the [-r]{.style-parameter} flag is set to limit the import to the regional bounds. 
- To speed up the import, the [memory]{.style-parameter} parameter should be set to be equal to the size of the import file. If that is not possible, use the maximum value that is possible on your system.

:::

As mentioned earlier, GRASS will import raster layers with the resolution and alignment of the original raster files. This means the computational region and the raster layers may not be perfectly aligned. In addition, the region’s resolution may not match that of the imported layers. To check this, you can run with the [-g]{.style-parameter} and compare the outcomes with those of the [r.info](https://grass.osgeo.org/grass-stable/manuals/r.info.html) module.

::: {#exm-uqHZOxgy43 .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
g.region -p
r.info map=bio_1
```

## {{< fa brands python >}}

``` python
gs.run_command("g.region", flags="p")
gs.run_command("r.info", map="bio_1")
```

## {{< fa regular window-restore >}}

Type in in the console to open the `g.region` dialog, and use the following parameter settings.

| Parameter                    | Value |
|------------------------------|-------|
| Print the current region (p) | ✅    |

: {tbl-colwidths="\[50,50\]"}

Open the `r.info` dialog, and run it with the following parameter settings:

| Parameter | Value |
|-----------|-------|
| map       | bio_1 |

: {tbl-colwidths="\[50,50\]"}
:::

If the extent differs, we use the [g.region](https://grass.osgeo.org/grass-stable/manuals/.html) module again, but this time with the [raster]{.style-parameter} parameter to set the region extent and resolution to match that of one of the imported bioclim layers[^2_obtaining_data-10]. We use the [save]{.style-parameter} parameter to save the current region settings as [region_aoi]{.style-data} for future use.

[^2_obtaining_data-10]: The different options of the `g.region` function provide a lot of flexibility in to how to define the region. You are encouraged to carefully consider the different options each time you use this module.

::: {#exm-V0FK31454 .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
g.region raster=bio_1 save=region_aoi
```

## {{< fa brands python >}}

``` python
gs.run_command("g.region", raster="bio_1", save="region_aoi")
```

## {{< fa regular window-restore >}}

Open the dialog of the `g.region` module, and run it with the following parameter settings:

| Parameter | Value      |
|-----------|------------|
| raster    | bio_1      |
| save      | region_aoi |

: {tbl-colwidths="\[50,50\]"}

## {{< fa question >}}

With the [raster]{.style-parameter} parameter, the region extent and resolution are set to match that of the specified raster layer (here bio_1). The [save]{.style-parameter} parameter saves the current region settings as a region file called [region_aoi]{.style-data}, which can be used later to quickly set the region to these settings again, for example when creating new mapsets. 

:::

It is important to note that the geographic region is defined per mapset. It is therefore the computational region of the mapset you are working in that defines the geographic area and resolution in which raster analyses are performed. See the [manual page](https://grass.osgeo.org/grass-stable/manuals/g.region.html) for more information.

::: {.callout-note appearance="simple"}
If a raster map does not match the resolution or extent of the current computational region, GRASS will resample it on the fly. By default, this resampling uses the nearest-neighbor method, which is not always the most appropriate choice. In such cases, it is better to resample the raster explicitly in advance, using a method suited to the data and analysis. See [menu: Raster → Develop raster map]{.style-menu} for options.
:::

@fig-bioclimvars shows the bioclimatic maps 1 to 19 that we have just imported for our study area. The maps also show the range map of the Almond-eyed Ringlet butterfly. In case you are interested, see [here](#sec-bioclimvars) for the code used to create the maps.

::: {#fig-bioclimvars layout-ncol="4"}
![](images/bio_1.png){group="LRNlhoGosy"}

![](images/bio_2.png){group="LRNlhoGosy"}

![](images/bio_3.png){group="LRNlhoGosy"}

![](images/bio_4.png){group="LRNlhoGosy"}

![](images/bio_5.png){group="LRNlhoGosy"}

![](images/bio_6.png){group="LRNlhoGosy"}

![](images/bio_7.png){group="LRNlhoGosy"}

![](images/bio_8.png){group="LRNlhoGosy"}

![](images/bio_9.png){group="LRNlhoGosy"}

![](images/bio_10.png){group="LRNlhoGosy"}

![](images/bio_11.png){group="LRNlhoGosy"}

![](images/bio_12.png){group="LRNlhoGosy"}

![](images/bio_13.png){group="LRNlhoGosy"}

![](images/bio_14.png){group="LRNlhoGosy"}

![](images/bio_15.png){group="LRNlhoGosy"}

![](images/bio_16.png){group="LRNlhoGosy"}

![](images/bio_17.png){group="LRNlhoGosy"}

![](images/bio_18.png){group="group"}

![](images/bio_19.png){group="group"}

Bioclimatic variable 1 to 19 from [Worldclim version 2.0](https://www.worldclim.org/data/bioclim.html). The red outlines show the distribution of the Almond-eyed Ringlet butterfly according to the [IUCN Red List](https://www.iucnredlist.org/species/173278/6984115). Click on the image to enlarge and view the maps in detail.
:::

## Future climates {#sec-obtainfutureclimatelayers}

To model the potential distribution of our species under future climate conditions, we use downscaled [future climate projections](https://www.worldclim.org/data/cmip6/cmip6climate.html) from Worldclim. There are bioclim data from 14 different general circulation models (GCMs) available for download. For each GCM, you can choose between data representing projected conditions in the periods (2021–2040, 241–2060, 2061–2080, and 2081-2100). You can furthermore choose between data based on the Shared Socio-economic Pathways ([SSPs](https://www.carbonbrief.org/cmip6-the-next-generation-of-climate-models-explained)) 126, 245, 370 and 585. We'll use the *2.5 arc-minute* bioclim variables for the period *2081-2100* based on the *SSP585* from the GCM [EC-Earth3-Veg]{.style-data}. Download the data and save it to your working directory.

Note that the future climate layers come as one multi-band GeoTiff file, unlike the current climate data where each bioclim variable is stored as a separate GeoTiff file. The file has 19 bands, representing the 19 bioclimatic variables. To verify this, you can use the [gdalinfo](https://gdal.org/en/latest/programs/gdalinfo.html) function from the command line.

We'll store the data in the [climate]{.style-data} mapset. To keep track of the different layers, we assign it the same name as the GCM: *EC_Earth3_Veg*.


::: panel-tabset
## {{< fa solid terminal >}}

``` bash
gdalinfo wc2.1_2.5m_bioc_EC-Earth3-Veg_ssp585_2081-2100.tif 
```

![`gdalinfo` prints the names and some basic information about each of the bands in the GeoTiff file. The names of the first two bands are marked with a red outline.](images/gdalinfo_futclim.png){#fig-gdalinfofutclim}
:::

The [r.in.gdal](https://grass.osgeo.org/grass-stable/manuals/r.in.gdal.html) module conveniently imports each band as a separate layer. The value of the [output]{.style-parameter} parameter will be used as prefix for the name of the imported raster layers, followed by the band number. If possible, use the [memory]{.style-parameter} parameter to increase the memory to be used by the module as this can speed up the import considerably.

::: {#exm-1a5tTJ1LeP .hiddendiv}
:::

::: {.panel-tabset}
## {{< fa solid terminal >}}

``` bash
r.in.gdal input=/home/paulo/Downloads/wc2.1_2.5m_bioc_EC-Earth3-Veg_ssp585_2081-2100.tif output=EC-Earth3-Veg_ssp585_2081-2100 memory=1000 -r
```

## {{< fa brands python >}}

``` python
gs.run_command(
    "r.in.gdal",
    flags="r",
    input="wc2.1_2.5m_bioc_EC-Earth3-Veg_ssp585_2081-2100.tif",
    output="EC-Earth3-Veg_ssp585_2081-2100",
    memory=1000,
)
```

## {{< fa regular window-restore >}}

Type in `r.in.gdal` in the console to open the dialog, and use the following parameter settings.

| Parameter | Value |
|----|----|
| input | wc2.1_2.5m_bioc_EC-Earth3-Veg_ssp585_2081-2100.tif |
| output | EC-Earth3-Veg_ssp585_2081-2100 |
| memory | 1000 |
| Limit import to current region (r) | ✅ |


## {{< fa question >}}

Remember that we set the computational region in the previous step so that:

- it matches the extent of our area of interest
- it matches the resolution of the current climate data
- it is aligned with the current climate data

As the future climate layers are derived from the same source as the current climate data, they have the same alignment and resolution as the current climate layers. By setting the computational region as we did, and by using the [-r]{.style-parameter} flag of the `r.in.gdal`, we ensure that the future climate layers are imported for the same geographic area and at the same resolution as the current climate layers.

:::

@fig-futbioclimvars shows the projected bioclimatic conditions for 2081-2100 (bioclim variables 1 to 19) that we have just imported for our study area. The maps also show the range map of the Almond-eyed Ringlet butterfly.

::: {#fig-futbioclimvars layout-ncol="4"}
![](images/futbio_1.png){group="NsFOs6E8BO"}

![](images/futbio_2.png){group="NsFOs6E8BO"}

![](images/futbio_3.png){group="NsFOs6E8BO"}

![](images/futbio_4.png){group="NsFOs6E8BO"}

![](images/futbio_5.png){group="NsFOs6E8BO"}

![](images/futbio_6.png){group="NsFOs6E8BO"}

![](images/futbio_7.png){group="NsFOs6E8BO"}

![](images/futbio_8.png){group="NsFOs6E8BO"}

![](images/futbio_9.png){group="\"NsFOs6E8BO"}

![](images/futbio_10.png){group="NsFOs6E8BO"}

![](images/futbio_11.png){group="NsFOs6E8BO"}

![](images/futbio_12.png){group="NsFOs6E8BO"}

![](images/futbio_13.png){group="NsFOs6E8BO"}

![](images/futbio_14.png){group="NsFOs6E8BO"}

![](images/futbio_15.png){group="NsFOs6E8BO"}

![](images/futbio_16.png){group="NsFOs6E8BO"}

![](images/futbio_17.png){group="NsFOs6E8BO"}

![](images/futbio_18.png){group="NsFOs6E8BO"}

![](images/futbio_19.png){group="NsFOs6E8BO"}

Projected bioclimatic conditions for the period 2081-2100 based on the SSP585 from the GCM EC-Earth3-Veg. Source: [Worldclim version 2.0](https://www.worldclim.org/data/bioclim.html). The red outlines show the distribution of the Almond-eyed Ringlet butterfly according to the [IUCN Red List](https://www.iucnredlist.org/species/173278/6984115). Click on the image to enlarge and view the maps in detail.
:::

<br><br>

## Footnotes {.unlisted .unnumbered .hidefootnotes}
